<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node.js App Basics - Part 2 · AndrewTheken.com</title><meta name="description" content="Node.js App Basics - Part 2 - Andrew Theken"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewtheken.com/atom.xml" title="AndrewTheken.com"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node.js App Basics - Part 2</h1><div class="post-info">Dec 31, 2014</div><div class="post-content"><hr>
<p>Feel free to review the other posts in this series:</p>
<ul>
<li><a href="/2013/09/01/Essential-Tools-for-node.js/">Part 0</a></li>
<li><a href="/2013/09/02/Node.js-App-Basics-Part-1/">Part 1</a> </li>
<li>Part 2 (You’re already here!)</li>
<li><a href="/2013/09/20/Node.js-App-Basics-Part-3/">Part 3</a> </li>
<li><a href="/2013/11/23/Node.js-App-Basics-Part-4/">Part 4</a></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>In this installement, let’s extend our server side to log requests, and to serve some static content.</p>
<p>As a quick refresher, here’s our server.js file from part 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//&apos;require&apos; says &quot;pull in this installed package&quot;</div><div class="line">var connect = require(&apos;connect&apos;);</div><div class="line"></div><div class="line">//we&apos;re still using Node&apos;s built in HTTP server, so let&apos;s pull it in.</div><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">//create our middleware stack (just send a basic message for now):</div><div class="line">var app = connect()</div><div class="line">    .use(function(request, response)&#123;</div><div class="line">        response.write(&apos;Hello from connect!&apos;);</div><div class="line">        response.end();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">//start a server on port 3000, any request that comes in should call</div><div class="line">//the &quot;app&quot; function that is our middleware stack from above.</div><div class="line">http.createServer(app).listen(3000);</div></pre></td></tr></table></figure>
<p>Open up your terminal, cd to the directory you created in part 1, and run:</p>
<pre><code>$ supervisor server.js
</code></pre><p>You can now open and <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> and updates to server.js will be visible each time you refresh.</p>
<p>As described previously, middleware can be added into a pipeline so that for each request that matches, various actions can be taken. The “connect” package we installed yesterday includes some useful middleware for us to get started:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var app = connect()</div><div class="line">	//add logging to all requests</div><div class="line">	.use(connect.logger())</div><div class="line">	//do the original request handling added in part 1.</div><div class="line">    .use(function(request, response)&#123;</div><div class="line">        response.write(&apos;Hello from connect!&apos;);</div><div class="line">        response.end();</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>Now that we’ve added logging, save ‘server.js,’ if you’re running this using supervisor, you can refresh your application in your browser and see that the requests made to your server are now logged in your terminal.</p>
<p>The line “.use(connect.logger())” can seem a bit strange at first, but this is doing something that is very common in modern Javascript (and other functional languages), connect.logger() is a function that returns a… <em>function</em>. </p>
<p>If you remember the description of middleware from part 1, that function’s signature is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function(request, response);</div></pre></td></tr></table></figure>
<p>Depending on which languages you’re familiar with, this passing of functions can feel a bit strange. <strong>Trust me, this ends up being critical to successful javascript/node.js development, and a major strength of the language, as we will see later.</strong></p>
<p>Another common scenario is to serve some static assets for things like css, client-side javascript, and (non-dynamic) html. A fairly standard convention in “rack-like” apps is that files located in a “public” folder in the root directory of your application will be served as static files. With the connect middleware, it’s very easy to add this functionality.</p>
<p>Let’s create a CSS, JS, and HTML file to illustrate this point.</p>
<p>Open a new instance of your terminal and cd to the base directory of your application.</p>
<pre><code>$ mkdir public
</code></pre><p>Next, create a file called “index.html” and paste this content into it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			font-family: arial;</div><div class="line">			padding: 0px;</div><div class="line">			margin: 0px;</div><div class="line">		&#125;</div><div class="line">		html&#123;</div><div class="line">			width: 100%;</div><div class="line">			background: #cfcfcf;</div><div class="line">		&#125;</div><div class="line">		body&#123;</div><div class="line">			text-align: center;</div><div class="line">			width: 80%;</div><div class="line">			margin: 20px auto;</div><div class="line">			padding: 10px;</div><div class="line">			background: white;</div><div class="line">			border-radius: 5px;</div><div class="line">			box-shadow: 0px 0px 5px 0px;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	Welcome to this static page!</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>Lastly, let’s add the connect middleware for static content to our stack in <em>server.js</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var app = connect()</div><div class="line">	//add logging to all requests</div><div class="line">	.use(connect.logger())</div><div class="line">	//serve &quot;static files from the public directory&quot;</div><div class="line">	.use(connect.static(__dirname + &apos;/public&apos;))</div><div class="line">	//do the original request handling added in part 1.</div><div class="line">    .use(function(request, response)&#123;</div><div class="line">        response.write(&apos;Hello from connect!&apos;);</div><div class="line">        response.end();</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p><strong>Note that <em>__dirname</em> is “special” in node, and refers to the directory from which the node process was started. This is your application’s “root”, so we are able to append “/public” to the end of it so that we serve static files out of the public directory that we just created.</strong></p>
<p>When you navigate to <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a>, the index.html will be served (many http servers, including connect, will look for index.html and serve it if you don’t include a file name in the url).</p>
<p>When you navigate to another url on the site, note that the “static” middleware doesn’t kick in, and our middleware from the first part of this tutorial kicks in and handles the response (i.e. <a href="http://localhost:3000/part1" target="_blank" rel="external">http://localhost:3000/part1</a>). <strong>This is a <em>very important</em> property of middleware, pay close attention to this and think about what the implications are.</strong></p>
<p>So far, I’ve left out one other important factor related to middleware, the concept of “next”, or “pass-through.”</p>
<p>You might have noticed that the logger middleware did not prevent the middleware that followed from running, and that the inclusion of the “static” middleware <em>did</em> prevent our base middleware from running, what’s going on?</p>
<p>To explain this, we need a brief digression into how javascript function parameters work…</p>
<p>Javascript functions can be defined with a certain number of parameters (this is called ‘<a href="http://en.wikipedia.org/wiki/Arity" target="_blank" rel="external">Arity</a>‘), but then called with a different number of parameters, so this is totally legal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var helloWorldMiddleware = function(request, response)&#123;</div><div class="line">  if(request.url === &apos;/hello_world&apos;)&#123;</div><div class="line">    response.write(&apos;Hello World!&apos;);</div><div class="line">  &#125;else&#123;</div><div class="line">    response.write(&apos;Goodbye Sweet World!&apos;);</div><div class="line">  &#125;</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">helloWorldMiddleware(obj1, obj2, obj3);</div></pre></td></tr></table></figure>
<p>In this case, obj3 will be totally ignored by the function (though you can still get to it if you want via a special “arguments” variable). Again, this may seem peculiar at first, but is actually a very useful property of the language.</p>
<p>To keep things simple, we wrote a middleware with an Arity of two, but connect will actually call the function with three arguments:</p>
<ol>
<li>request (usually abbreviated ‘req’)</li>
<li>response (usually abbreviated ‘res’)</li>
<li>callback (usually called ‘next’, or ‘done’)</li>
</ol>
<p>Notice that we have a new parameter “callback,” which can be used to pass control on to the next middleware if we do not wish to modify the response (as is the case with the logger middleware, and the static middleware when no static file matches the requested url path).</p>
<p>Let’s modify the <em>helloWorldMiddleware</em> I described above, allowing it to return ‘Hello World!’ when the path matches, but passing control to our original middleware when it does not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//produce a special message when the url matches.</div><div class="line">function(req, res, next)&#123;</div><div class="line">	 	if(req.url === &apos;/hello_world&apos;)&#123;</div><div class="line">	 		res.write(&apos;Hello World!&apos;);</div><div class="line">	 		res.end();</div><div class="line">	 	&#125;else&#123;</div><div class="line">	 	  //pass control to the next middleware in the stack...</div><div class="line">	 		next();</div><div class="line">	 	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>If you’ve been following along, this is what your <em>server.js</em> file should have in it at this point:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//&apos;require&apos; says &quot;pull in this installed package&quot;</div><div class="line">var connect = require(&apos;connect&apos;);</div><div class="line"></div><div class="line">//we&apos;re still using Node&apos;s built in HTTP server, so let&apos;s pull it in.</div><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">//create our middleware stack (just send a basic message for now):</div><div class="line">var app = connect()</div><div class="line">	//add logging to all requests</div><div class="line">	.use(connect.logger())</div><div class="line">	 //serve &quot;static files from the public directory&quot;</div><div class="line">	 .use(connect.static(__dirname + &apos;/public&apos;))</div><div class="line">	 //produce a special message when the url matches.</div><div class="line">	 .use(function(req, res, next)&#123;</div><div class="line">	 	if(req.url === &apos;/hello_world&apos;)&#123;</div><div class="line">	 		res.write(&apos;Hello World!&apos;);</div><div class="line">	 		res.end();</div><div class="line">	 	&#125;else&#123;</div><div class="line">	 	  //pass control to the next middleware in the stack...</div><div class="line">	 		next();</div><div class="line">	 	&#125;</div><div class="line">	 &#125;)</div><div class="line">	//do the original request handling added in part 1.</div><div class="line">	.use(function(request, response)&#123;</div><div class="line">		response.write(&apos;Hello from connect!&apos;);</div><div class="line">		response.end();</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">//start a server on port 3000, any request that comes in should call</div><div class="line">//the &quot;app&quot; function that is our middleware stack from above.</div><div class="line">http.createServer(app).listen(3000);</div></pre></td></tr></table></figure>
<p>Navigating to <a href="http://localhost:3000/hello_world" target="_blank" rel="external">http://localhost:3000/hello_world</a> should produce</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>While navigating to another path (like: <a href="http://localhost:3000/another_path" target="_blank" rel="external">http://localhost:3000/another_path</a>) should produce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello from connect!</div></pre></td></tr></table></figure>
<p><strong>I’ll cover this in more detail in the next part of this tutorial, but this is <em>very important</em>, each middleware you create <em>must</em> either modify the request (usually by writing content to the response object), or call the callback (next()/done()). If your middleware doesn’t do this for every codepath, you will hang up your node server, and no new requests will be processed.</strong></p>
<p>In the next part of the series, we’ll talk about the node process model, and start to dig into one of the central concepts in node.js, <strong>asynchronicity</strong>.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/31/2013-09-02-Node.js-App-Basics-Part-1/" class="prev">PREV</a><a href="/2014/12/31/2013-09-20-Node.js-App-Basics-Part-3/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://andrewtheken.com">Andrew Theken</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>