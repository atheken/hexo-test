<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Observations on Swift · AndrewTheken.com</title><meta name="description" content="Observations on Swift - Andrew Theken"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewtheken.com/atom.xml" title="AndrewTheken.com"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Observations on Swift</h1><div class="post-info">Dec 31, 2014</div><div class="post-content"><p><strong>I’m sure not all will agree, but I’ve hinted at having issues with the language for a couple of months now, so I thought I’d try to cover what I’ve been talking about.</strong></p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><p>Coming from a C# background, and having dabbled in Obj-C for years, I was excited to see a new language be supported for iOS/OS X development. After having spent some time playing with the language, I’ve noticed a number of percieved shortcomings.</p>
<p>Before I continue, please keep in mind that a lot of this is based on coming from a language that I love, C#, to Swift. I think it’s fair to contextualize a lot of shortcomings and trade-offs in the history and use of Obj-C, but I don’t think Swift should just get a pass, these were solved problems in other languages.</p>
<h2 id="The-good"><a href="#The-good" class="headerlink" title="The good:"></a>The good:</h2><p>It’s commendable that Apple has attempted to bridge Swift and Obj-C, and there are certainly cases where this required modifications to the Swift language to support that interop. As such, Swift is a language of trade-offs, and latitude must be given its designers. I also think that one of Swift’s key improvements is strong-typing, which allows for more robust applications - especially where the team and codebase grow too large to keep track of everything in your head.</p>
<p>Swift also attempts to reduce the need to deal with pointers (directly) even further than ARC, a pain point for beginners and seasoned professionals alike. Fewer pointers makes Swift slightly more approachable than Obj-C, and playgrounds are somewhat helpful in exploring the features of the language. </p>
<p>The Swift design team also seems to have been responsive to the community of Obj-C developers, after Apple had incubated the language privately for several years. </p>
<p>I think that a lot of my gripes will be addressed over time, but it’s clear that fundamental design decisions were made in the language. I am concerned that those decisions are going to hinder the progress of the language.</p>
<h1 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a><em>Observations</em></h1><h2 id="Async"><a href="#Async" class="headerlink" title="Async:"></a>Async:</h2><p>There’s no native support for “async.” Yes, we got closure completions, but threading has always been an important part of Run-loop applications. Closures (and blocks) simplify “callback hell,” but do not eliminate it (especially in even marginally “advanced” animations). The simplicity of having first class support for async/continuations can’t be overstated, as demonstrated in this hypothetical version of async syntax:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async func animateView()-&gt;Void&#123;</div><div class="line"></div><div class="line">	// Run-loop continues while animation runs.</div><div class="line">	await UIView.animate(self.view, duration: 0.25, </div><div class="line">		animations: &#123; self.view.alpha = 0.5 &#125;)</div><div class="line"></div><div class="line">	// Run-loop returns after animation runs.</div><div class="line">	UIView.animate( self.view, duration:0.25, </div><div class="line">		animations: &#123;self.view.alpha = 1.0 &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Inclusion of “real” async support would have been a significant advance for the platform.</p>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators:"></a>Operators:</h2><p>Support for custom operators allows for “opaque” syntaxes. Take this one, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">	//do some work </div><div class="line">&#125; ~&gt;</div><div class="line">&#123;</div><div class="line">	//do some more work</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This above operator (~&gt;) was suggested as a way to support an async “background worker -&gt; foreground continuation” pattern, since the language lacks it. </p>
<p>As I mentioned, I think async should have been a first-class component of the language, but this syntax will be completely non-obvious for a beginner. It’s compounded by the fact that every single project you work with may choose to define a different operator for this. </p>
<p>While I think it’s likely that these “high-level” operators will become idiomatic and most projects will adopt the same notation, I see this as more of an opportunity for making a quagmire, than convenience.</p>
<h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation:"></a>Documentation:</h2><p>There’s no support for “first-class” documentation. The IDE should provide a way to produce ‘javadoc’ style comments. </p>
<p>I’ll admit, I have always felt that the documentation from Apple has been too focused on tasks, and not focused enough on learning the API. I think you need both, but learning to develop for iOS/OSX is about learning the API, and a way to survey the API is to read through the types and their members. </p>
<p>First-class documentation would emphasized the need to document the purpose and capabilities of both Apple and Third-party APIs.</p>
<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection:"></a>Reflection:</h2><p>Swift is a strongly-typed language, but there’s no simple way to get the type of an instance at runtime. The counter-argument is that you shouldn’t “care” about the type, and just call “respondsToSelector” or chain the safe-navigation operator (‘?’), but sometimes you really do need the type information.</p>
<h2 id="Events-KVO"><a href="#Events-KVO" class="headerlink" title="Events/KVO:"></a>Events/KVO:</h2><p>KVO, an extremely powerful and important feature of Obj-C, is effectively not supported in <em>native</em> Swift. </p>
<p>What replaces KVO on the Swift side? Nothing. </p>
<p>Swift does include a useful syntax for observing changes on self’s own properties (which, I actually really like). Unfortunately, this willSet/didSet property syntax doesn’t allow for an elegant way to update the UI when a model changes. </p>
<p>If you’re trying to go “swift-only”, you’ll probably want some sort of PubSub/Event-sourcing to deal with this, so you’ll need to write your own.</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions:"></a>Exceptions:</h2><p>While I agree that throwing exceptions was overused in Java, and even in C#, I feel that excluding them entirely was an incorrect decision - here’s when exceptions are useful:</p>
<ul>
<li>Exhaustion of physical resources (RAM, HD, maybe CPU)</li>
<li>An external process is not accessible (SQL Database, web service)</li>
</ul>
<p>In more general terms, these are <em>“unrecoverable errors.”</em> The process cannot really do anything to make more hard drive space, and shouldn’t be responsible for rebooting a SQL server. These are exceptional circumstances. Worse, the runtime can produce “exceptions” when you do something illegal. Unfortunately, there’s no way to actually catch those and log them, or even easily debug them, because Swift has no notion of “exception”.</p>
<p>Additionally, the exclusion of an exception system serves continuing “Nil-lust” - Where, when assertions for inputs are not met, “Nil” is returned. Nil/null means something very specific: “The answer is undefined”, and this should be handled differently than “The answer was undefined, because you didn’t provide good inputs.” The language’s idioms don’t recognize the difference.</p>
<p>Yes, we can have NSError bleed through our APIs, but this is really not different than declaring all the types of exceptions that a method in Java could throw. I don’t know what the right answer is, but excluding the concept entirely doesn’t seem to be it.</p>
<h2 id="Incomplete-Type-Inference-Excessive-Coercion"><a href="#Incomplete-Type-Inference-Excessive-Coercion" class="headerlink" title="Incomplete Type Inference/Excessive Coercion:"></a>Incomplete Type Inference/Excessive Coercion:</h2><p>Type inference. I love type inference, I think it’s hugely valuable in making working with strong type systems more fluid. However, the removal of implicit casting when it is safe, diminishes the benefits of inference. For example, C# allows for implicit casting when precision would not be lost (i.e. Int -&gt; Double). As a general rule, if you need explicit casting, you’re “doing it wrong.”</p>
<h2 id="Multiple-Inconsistent-Syntaxes"><a href="#Multiple-Inconsistent-Syntaxes" class="headerlink" title="Multiple Inconsistent Syntaxes:"></a>Multiple Inconsistent Syntaxes:</h2><p>Swift has many syntaxes to achieve the same end result. This expands the overall syntax “surface,” making it challenging for learners of the language to read code.</p>
<p>For struct, the keyword needed to get a static member is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct AStructure&#123;</div><div class="line">	//note that &quot;static&quot; is the right keyword here, not &quot;class&quot;</div><div class="line">	static var StoredProperty = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>But, for classes, the “class” keyword will be used:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class AClass&#123;</div><div class="line">	// Note, as of XCode 6.1 GM, &quot;class&quot; </div><div class="line">	// and &quot;static&quot; aren&apos;t supported on class anyway.</div><div class="line">	// Error implies this will be the syntax.</div><div class="line">	class var StoredProperty = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This inconsistency requires a human to shift from right-brain activity, where algorithms and data structures get written (i.e. real work), to the left-brain activity, where the actual construction of syntax gets managed.</p>
<p>Specifying the keyword on a class doesn’t alter the class, but modifies its members. There’s a cognitive disconnect between the thing you’re touching, and the thing you’re modifying:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class AClass&#123;</div><div class="line">	//public</div><div class="line">	func AFunc() -&gt; Void</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>vs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class AClass&#123;</div><div class="line">	//changes to private</div><div class="line">	func AFunc()-&gt;Void</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Optional, and non-optional parameter names in functions contribute to the mess. Suppose I have these (fictional, and maybe nonsensical) methods included in a UIView category:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func addSubviewWithName(name:String, view:UIView) -&gt; Void &#123;&#125;</div></pre></td></tr></table></figure>
<p>vs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func addSubview(_ name:String, view:UIView) -&gt; Void &#123;&#125;</div></pre></td></tr></table></figure>
<p>In the first, calling view.addSubviewWithName(“foo”, view:v2) results in a compiler error, while in the second, calling view.addSubview(name:”foo”, view:v2) results in an error. I now need to remember which syntax to use in each case and that will be driven by the function definition. Given the history of Obj-C and Swift, the parameter naming is imporatant, but I’m still unsure whether “_” was the right solution.</p>
<p>The constructions for function definitions and closures are unnecessarily different:</p>
<p>Given the following function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func ALongRunningTask(completion:(Bool)-&gt;Void) -&gt; Void &#123; completion(true) &#125;</div></pre></td></tr></table></figure>
<p>This is the call for it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALongRunningTask()&#123; b in NSLog(&quot;%@&quot;, b)&#125;</div></pre></td></tr></table></figure>
<p>The syntax could have been</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Isn&apos;t very pretty, but doesn&apos;t require another syntax construction</div><div class="line">ALongRunningTask() b -&gt; &#123; NSLog(&quot;%@&quot;, b)&#125;</div></pre></td></tr></table></figure>
<p>Generics aren’t described the same way between classes, protocols, and extensions:</p>
<p>For Structs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//type parameter required</div><div class="line">struct Stack&lt;T&gt; &#123;</div><div class="line">    var items = [T]()</div><div class="line">    mutating func push(item: T) &#123;</div><div class="line">        items.append(item)</div><div class="line">    &#125;</div><div class="line">    mutating func pop() -&gt; T &#123;</div><div class="line">        return items.removeLast()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>For Extensions:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//no type parameter required</div><div class="line">extension Stack &#123;</div><div class="line">    var topItem: T? &#123;</div><div class="line">        return items.isEmpty ? nil : items[items.count - 1]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>For Protocols:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//no type parameter required, but &quot;typealias&quot; must be specified.</div><div class="line">protocol Container &#123;</div><div class="line">    typealias ItemType</div><div class="line">    mutating func append(item: ItemType)</div><div class="line">    var count: Int &#123; get &#125;</div><div class="line">    subscript(i: Int) -&gt; ItemType &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Again, I have to remember more syntax for effectively the same concept.</p>
<h2 id="Fixing-the-Un-broken"><a href="#Fixing-the-Un-broken" class="headerlink" title="Fixing the Un-broken:"></a>Fixing the Un-broken:</h2><p>The Swift syntax also seems to have attempted to solve problems we didn’t know we had, and, <em>in my opinion</em>, creates some that were non-existant:</p>
<p>Optional semi-colons. Touted as a feature, this seems like a waste of engineering effort. Require the semi-colons, and your checks for “is this a valid statement” become dramatically simpler. As programmers, we know how to type, ‘;’ - it doesn’t even require coordination with a shift key, semi-colons are required in a huge number whitespace-insensitive languages (C, Obj-C, C++, C#, PHP, Javascript*). Worse, in making ‘;’ optional seems to lead to spurious or incorrect compilation errors - often focusing attention on the wrong syntax problem in the IDE. I’d even go so far as to argue that excluding them will lead to lower “readability”, as lines glob together.</p>
<p>Unneccessary changes to syntax in the name of “readability” (Though, I would like to see actual data to prove this. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//what language uses this syntax?</div><div class="line">var l = [NSObject]() </div><div class="line"></div><div class="line">// C-drived languages, your developer&apos;s bread-and-butter, </div><div class="line">// do it like this:</div><div class="line">var l = NSObject[]</div></pre></td></tr></table></figure>
<p>I also generally disagree that the order of the function definition makes sense for someone learning the API. This is bound to be a <em>“holy-war”</em> inducing argument. <em>You have been warned</em>:</p>
<p>In OOP, frequently, your task is to acquire (or be handed) the correct instance of a certain type of object, and then send messages to it to achieve your goal. The extremely verbose nature of the method names, combined with the de-emphasis of what the return value is, makes the func syntax unwieldy.</p>
<p>I understand the parameter naming is to support Obj-C compatibility, but I think that the focus still needs to be on acquiring objects of certain types and then working with those objects.</p>
<p>The way I personally work is to think about my destination (a specific application state), and work back from there to the input parameters I have. So, when I’m looking at an API, I’m following a chain back to the inputs I’m handed. By putting the parameters before the return type, I need to sift through the whole API to find candidate methods. In addition, the the function syntax is completely inconsistent with C and its derived languages.</p>
<p>I also think the return type serves to emphasize the difference between a stateful or functional interaction, and is therefore even more important in a language that tries to support both.</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions:"></a>Conclusions:</h2><ul>
<li>Swift feels like a very piecemiel language, where the syntax was concieved in parts, and lack consistency in their design. The syntax feels “deliberately different,” which I think is a solution in search of a problem.</li>
<li>Swift attempts to eliminate “unsafe” concepts, without providing reasonable alternatives (like Exceptions)</li>
<li>Swift serves too many audiences. Swift is not a language for beginners; The syntax surface is too large, and the number of paradigms it supports is too broad. At the same time, core features of the iOS/OSX platform(s) are not supported, which limits its value to advanced developers that already know Obj-C.</li>
<li>As of 10/6/2014, the Swift compiler/runtime are very buggy, compiler errors are misleading, which leads to wild-goose chases to get the “magic” syntax correct. In just the little bit of playing I’ve done, I’ve seen reference assignments get optimized out, leading to messages being sent to the wrong objects, leading to “Exceptions” that can’t be caught and are hard to debug, because they originate in object code.</li>
<li>The core of iOS/OS X has been Obj-C for (technically) more than 15 years. You will need to use Obj-C, you can’t “just use Swift.” - Until you can build an elegant, reliable app in Swift, it’s probably not worth your frustration to use it.</li>
</ul>
<hr>
<p>Finally, I realize all of this is an “outsider’s” perspective, based on my experience in other platforms. I’d love to get your feedback in understanding the language, platform, and context better. Feel free to send me (love) notes on Twitter: <a href="http://www.twitter.com/atheken" target="_blank" rel="external">@atheken</a>. And to correct my assumptions in the comments.</p>
<p>//Andrew</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/31/2013-11-23-Node.js-App-Basics-Part-4/" class="prev">PREV</a><a href="/2014/12/31/2014-03-09-sql-performance-hints/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://andrewtheken.com">Andrew Theken</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>