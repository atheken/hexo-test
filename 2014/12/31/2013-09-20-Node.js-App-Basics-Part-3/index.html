<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node.js App Basics - Part 3 · AndrewTheken.com</title><meta name="description" content="Node.js App Basics - Part 3 - Andrew Theken"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewtheken.com/atom.xml" title="AndrewTheken.com"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node.js App Basics - Part 3</h1><div class="post-info">Dec 31, 2014</div><div class="post-content"><hr>
<p>Feel free to review the other posts in this series:</p>
<ul>
<li><a href="/2013/09/01/Essential-Tools-for-node.js/">Part 0</a></li>
<li><a href="/2013/09/02/Node.js-App-Basics-Part-1/">Part 1</a> </li>
<li><a href="/2013/09/03/Node.js-App-Basics-Part-2/">Part 2</a></li>
<li>Part 3 (You’re already here!)</li>
<li><a href="/2013/11/23/Node.js-App-Basics-Part-4/">Part 4</a></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>Alright, so now we’re getting into the fun stuff!</p>
<h1 id="Asynchronicity"><a href="#Asynchronicity" class="headerlink" title="Asynchronicity"></a>Asynchronicity</h1><p>Node.js is a great example where chosing to rigorously stick to a constraint can really pay off.</p>
<p>As you might know, JavaScript is, by definition, single-threaded (for our purposes, accept this as true). What this means is that you can do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//WARNING: You should NEVER do this </div><div class="line">//in javascript! (and maybe nowhere)</div><div class="line"></div><div class="line">//set up JS to fire an event after 1 millisecond...</div><div class="line">setTimeout(function()&#123;</div><div class="line">	console.log(&apos;called!&apos;);</div><div class="line">&#125;, 1);</div><div class="line"></div><div class="line">while(true)&#123;</div><div class="line">	//do nothing, but watch your CPU peg! ;-)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>And the function with the log call will never get called, simply because the while loop is running in a single thread, and the “event” that should fire after one millisecond will not happen until after the while loop completes.</p>
<p>This behavior makes working with javascript conceptually very easy, as you don’t need to deal with any pesky locking structures for things that might otherwise happen simultaneously. For example, within a function body, there’s no chance of shared state getting modified by another thread.</p>
<p>In Node.js, this means that all logic we write will run on a single thread, and due to the nature of node, this quality forces libraries to be developed in a non-blocking way. The above code snippet is “blocking” in that the while loop will continue to run indefinitely, and since we’ve only got one thread, this means all other work on this node process will also be halted (and this is basically true in the browser, too).</p>
<p>Let’s try to put this notion into perspective:</p>
<p>You go out to a nice, busy, restaurant. It’s a pretty fancy place, and only has few tables available. Unfortunately, you didn’t plan ahead, and all the tables are in use by other folks. The host is quite polite, and takes down your phone number. He’ll call you as soon as a table becomes available. This is great because you don’t have to stand by the door, waiting. Instead, you’re freed up to go and have a drink at the bar. This also allows other customers (who also didn’t plan ahead) to come in and ask to be called when a table is available. Eventually, a table frees up, and the host calls you back to let you know you can now be seated for dinner. This system works well for both you and the restaurant, they can serve customers very efficiently, and you can enjoy a drink at the bar while waiting (instead of just standing in the way, staring the host down!).</p>
<p>Whether you believe me yet, Node.js (and in general, asynchronous programming models) attempt to have the same interaction as described above. Instead of you, as a customer requesting a table, we can think of your node.js application making a request to an external resource (like a database, or the file system, or a web service). Most of the time this will introduce <em>a lot</em> of waiting around, and node.js has been optimized to make the best of this situation.</p>
<p>To simplify, this is the model that node is designed for:</p>
<ol>
<li>Node process makes request for “slow” resource, providing a “callback” function for when it completes.</li>
<li>Node process continues to do other work, including additional requests to other resources.</li>
<li>The “callback” function is called, with any potential error information, or response data if no error occurred.</li>
</ol>
<p>Here’s a simple example using “<a href="https://npmjs.org/package/nano" target="_blank" rel="external">nano</a>,” a very nice and simple package for using <a href="http://couchdb.apache.org" target="_blank" rel="external">CouchDB</a> in node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//assume &quot;db&quot; is a connection to a database.</div><div class="line"></div><div class="line">//look up the record with &quot;this_is_a_key&quot; as the id.</div><div class="line">db.get(&apos;this_is_a_key&apos;, function(error, data)&#123;</div><div class="line">	if(error)&#123;</div><div class="line">		console.log(&quot;An error occurred when looking &quot;+</div><div class="line">			&quot;up the record for the key.&quot;, error);</div><div class="line">	&#125;</div><div class="line">	else&#123;</div><div class="line">		console.log(&quot;Got some data, w00t!&quot;, data);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>(Don’t worry if you don’t understand all of this, the main point is to see how the callback works.)</p>
<p>The example is a bit contrived, but the point is that there are almost no “blocking” functions in javascript, instead, the preferred style for anything that would normally block is to provide a callback and then observe the data/error when it becomes available. Note that in many cases, it is possible to exclude a callback, this is sometimes called “fire and forget,” and there are cases when this is beneficial.</p>
<p>The above example works great for when you have a “one and done” requirement. But another common case is that I need to manipulate a large batch of records. Since reading data from an external source is (at least) 10x slower than reading it from memory, it might be nice to be able to do the manipulation on records as they become available. </p>
<p>Because node uses an “event loop” this ends up being very simple, and not much different than the example above.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//Assume a db created, and there&apos;s a </div><div class="line">//method that returns an &quot;EventEmitter&quot;</div><div class="line"></div><div class="line">//get an object that will fire and </div><div class="line">//event each time a row is available.</div><div class="line">var selection = db.getRows();</div><div class="line"></div><div class="line">//listen for &quot;row&quot; events as the rows </div><div class="line">//become available and handle them.</div><div class="line">selection.on(&apos;row&apos;, function(data)&#123;</div><div class="line">	console.log(&apos;row became available&apos;, data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//it is common with this sort of </div><div class="line">//model to listen for an &quot;error&quot; event separately.</div><div class="line">selection.on(&apos;error&apos;, function(error)&#123;</div><div class="line">	console.log(&apos;an error happend. darn!&apos;, error);	</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>The key difference here, is rather than having a single callback, we define callbacks to handle specific events that could happen once we cause the data selection action to occur. (See the <a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter docs here</a>.) The event-based model is common in many languages, so this might already be familiar to you.</p>
<p>Understanding Asynchronicity is <em>really</em> important in node.js, and, is the main reason why a single node process is able to scale so well (though, v8 is also pretty fast, and serves as a good base from which to build). The “single non-blocking thread” constraint allows us to use our CPU very efficiently, but as you can see in the first code snippet above, it’s also <em>really</em> easy to do something that can get you into trouble.</p>
<p>Now that we’ve covered this fundamental part of node.js, we can get back to our wikipedia search app in the next installment.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/31/2013-09-03-Node.js-App-Basics-Part-2/" class="prev">PREV</a><a href="/2014/12/31/2013-11-23-Node.js-App-Basics-Part-4/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://andrewtheken.com">Andrew Theken</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>